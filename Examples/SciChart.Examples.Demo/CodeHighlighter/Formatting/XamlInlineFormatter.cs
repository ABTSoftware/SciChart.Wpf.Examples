// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.
// <auto-generated />
// No style analysis for imported project.

using System.Collections.Generic;
using System.Windows.Media;
using System.Windows.Documents;
using CodeHighlighter.Parsing;

namespace CodeHighlighter.Formatting
{
    // CONSIDER: background worker to improve performance, with all UI
    // generation at the end.

    internal class XamlInlineFormatter : IFormatter
    {
        private Paragraph _text;

        /// <summary>
        /// Initializes a new instance of the XAML inline formatter which will
        /// store the contents of the syntax highlighting results into the
        /// text block instance.
        /// </summary>
        /// <param name="paragraph">The text block.</param>
        public XamlInlineFormatter(Paragraph paragraph)
            : this()
        {
            _text = paragraph;
        }

        protected XamlInlineFormatter()
        {
        }

        public void Write(string parsedSourceCode,
                          IList<Scope> scopes,
                          IStyleSheet styleSheet)
        {
            int offset = 0;
            bool lastScopeWasComment = false;

            foreach (Scope scope in scopes)
            {
                string t = parsedSourceCode.Substring(scope.Index, scope.Length);
//                    .Replace("\r\n", "\n")
//                    .Replace("\r", "\n");
                offset = scope.Index + scope.Length;
                if (!string.IsNullOrEmpty(t))
                {
                    if(scope.Name == "XML Attribute")
                    {
                        //Add space before attributes
                        t = t.Insert(0, " ");
                    }

                    Inline run = new Run { Text = t.Replace("\r",string.Empty) };
                    if (scope != null && styleSheet.Styles.Contains(scope.Name))
                    {
                        Style style = styleSheet.Styles[scope.Name];
                        run.Foreground = new SolidColorBrush(style.Foreground);
                    }
                    lastScopeWasComment = (scope != null && scope.Name == "Comment");
                    _text.Inlines.Add(run);
                }
            }
            string left = parsedSourceCode
                .Substring(offset)
                .Replace("\r\n", "\n")
                .Replace("\r", "\n");
            if (!string.IsNullOrEmpty(left))
            {
                for (int i = left.IndexOf("\n"); i >= 0; i = left.IndexOf("\n"))
                {
                    if (i > 0)
                    {
                        Inline tby = new Run { Text = left.Substring(0, i) };
                        _text.Inlines.Add(tby);
                    }

                    left = left.Substring(i + 1);
                    if (lastScopeWasComment)
                    {
                        lastScopeWasComment = false;
                    }
                    else
                    {
                        _text.Inlines.Add(new LineBreak());
                    }
                }

                if (!string.IsNullOrEmpty(left))
                {
                    Inline nrun = new Run { Text = left };
                    _text.Inlines.Add(nrun);
                }
            }
        }
    }
}